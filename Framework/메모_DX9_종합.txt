
바이너리 파일: 2진 파일
예) exe 파일. exe 파일은 모든 cpp와 h를 번역해서 보관하고 있다.
사운드 파일, Png 등등.. 리소스들


bin 폴더(바이너리 폴더): 어디다가 똑 떼어놔도 실행되도록 만든다.
private 폴더: cpp 파일을 담는다.
public 폴더: h 파일을 담는다.
Default 폴더: 나머지

1. 프로젝트를 추가하고, 그걸 Default 폴더로 옮긴다.
2. VS에서 프로젝트를 삭제한다. (잘못된 경로 참조기 때문에)
3. VS에서 기존 프로젝트 추가
4. CMainApp 클래스 추가
5. 헤더 경로 수정: ../public/CMainApp
6. cpp 경로 수정: ../private/CMainApp
7. exe를 바이너리 폴더에 저장하고 싶다면?
8. 클라이언트 프로젝트 -> 우클릭 -> 속성 -> 모든 구성 선택 -> 출력 디렉터리 -> 다 지움 -> 찾아보기 -> 바이너리 폴더 지정
-> 폴더 이름이니까 bin 뒤에 / 붙여줌. 예) ../bin/
9. 디버그 해보기
10. 도구탭 -> 설정 가져오기 및 내보내기 -> 알잘딱 -> visual C++
11. 모든 디폴트 헤더 및 소스  default 필터에 다 박기.
12. 소스, 헤더 필터 다 지우기
13. 기본 윈도우 정리
14. 클라이언트 디파인스 헤더 추가
15. 속성 -> 모든 구성 -> C++ -> 추가 포함 디렉터리 -> ../Public/ (헤더 추가할때 ../Public/ 추가하기 귀찮아서)
16. InitInstance에 창 사이즈와 g_hWnd 세팅
17. MainApp에 클래스 순서 정리되어 있음.
18. 생성자와 소멸자를 private or protected로 제한하는 이유
new를 할 수 없도록 하기 위해서다. 다른 곳에서 생성자를 호출할 수 없게 하기 위해서다.
다른 개발자가 정해진 루틴을 무시하고 new를 할 수 있기 때문에 new를 막는다.
19. 면접 질문: 객체와 클래스의 차이점에 대해 말해보세요.
클래스는 틀, 객체는 틀을 이용해서 메모리를 할당한 인스턴스
20. 변수를 public으로 두면 안되는 이유는? 어차피 Get Set하잖아?
클래스를 사용하는 이유는 기능에 중점을 두기 때문에 함수가 중요하다. 즉, 어떤 클래스 안의 함수를 쓰기 위해서 변수를 선언하는 것이다.
그래서 선언되는 것이 멤버 변수다. 따라서 가급적으로 부모 변수들도 private으로 제한한다.
예를 들어 좌표를 수정하기 위해서라면 Move라는 함수를 부모에 정의해놓고 자식에서 움직일 때 Move()를 호출한다.
가급적 Get Set을 만들지 마라. 그 변수를 제어하는건 그 클래스 안에서 처리해라.
21. 소멸자는 거의 안쓴다.
22. 모든 클래스의 부모는 CBase고, CBase에선 레퍼런스 카운트를 관리한다.
23. ObjMgr에 저장을 하더라도 레퍼런스 카운트를 올리진 않는다. 원래 저장 위치에는 레퍼런스 카운트를 올리지 않는다.
24. 클래스의 인스턴스가 삭제될 때, 모든 멤버 변수를 삭제한다. (Release)
25. 즉, 주소가 있다면 레퍼런스 카운트를 1만큼 감소한다. 레퍼런스 카운트가 0이라면 객체가 삭제된다.
26. 무조건적인 delete 호출은 금지된다. 따라서 소멸자도 private다.
즉, 모든 클래스가 공통적으로 Release()와 AddReference()한다. 즉, CBase에서 한다. (생각: 참조 중인 객체도 등록해주자.)
27. Safe_Release(디바이스)에서 실제로 디바이스가 릴리즈(레퍼런스 카운트 때문에) 안됨!!!! 메모리 누수
28. CBase의 Release()는 감소 이전의 레퍼런스 카운트를 리턴한다. 0일 때 삭제 체크하기 위해서다.
CBase의 AddRef()는 증가된 레퍼런스 카운트를 반환한다.
29. 컴객체도 같은 방식으로 동작한다.
30. 소멸자는 안쓴다. 왜냐? virtual 소멸자라서 아래서부터 위로 소멸한다. 
가상 소멸자에서 delete this를 하면 아래서 위로 올라가면서 터진다.
따라서 소멸 전에 소멸 함수를 호출하고 delete한다. 또한 소멸 순서를 제어하기 위해 소멸 함수를 따로 둔다. 
31. 그래서 Free를 둔다. Free 앞에 항상 Super::Free() 호출한다.


2일차

1. 엔진 필터에 Win32 프로젝트 추가
2. 윈도우즈 응용프로그램 말고 DLL로 만들자.
3. 빈 프로젝트 체크
4. 우린 이미 D3DX 라이브러리를 쓰고 있다.
5. 엔진 프로젝트는 여러 클라이언트 개발자가 동일하게 사용하는 기능들을 모은다.
특정 클래스에만 쓰는 기능이 있으면 안된다.
6. 윈도우 프로젝트를 릴리즈하면 exe 파일에 내 모든 코드가 들어간다. 마찬가지로 라이브러리도 포함되서 들어가는데,
쓰지 않는 기능도 마찬가지로 exe에 들어간다.
7. 오브젝트 매니저는 엔진으로, 몬스터는 클라이언트로 간다.
CBase 클래스도 엔진이다.
8. Base cpp와 h를 엔진 프로젝트(솔루션 탐색기) 드롭한다.
9. 엔진 프로젝트 속성에 C++ 탭이 추가되어 있다.
10. CBase가 엔진으로 갔으니, 클라이언트에게 엔진DLL을 알려줘야한다.
11. 엔진에서 클라이언트의 헤더를 인클루드하면 안된다.
12. 클라이언트에서 엔진의 헤더를 가져와도 된다. 클라이언트는 엔진에게 의존성을 띈다.
13. 쓸 함수들을 포함한 헤더들 추가
14. 속성에서 D3DX9 라이브러리 포함
15. 싱글톤은 레퍼런스 카운트를 쓰는가?
쓴다. 레퍼런스 카운트는 생성 개수를 세는게 아니라, 해당 객체를 몇 곳에서 참조하고 있는지를 센다.
따라서 Engine_Macro.h에서 Destroy_Singleton을 delete하는게 아니라 Safe_Release한다.
16. BEGIN과 END 매크로 추가.
17. 앞으로 namespace Engine을 사용한다. 중복된 이름을 사용하지 않으려고.
클라이언트 개발자가 Engine 프로젝트의 모든 클래스와 함수 이름을 알고 겹치지 않게 쓸 수 있나?
아니다. 따라서 namespace Engine으로 구분한다.
18. 빌드하면 dll만 있다. 이제 라이브러리화 시켜라.
19. 클래스 이름에 _declspec(dllexport) 붙여줘라.
20. 이제 빌드하면 lib 파일이 생긴다.
21. 보내기용 클래스와 사용자 입장의 클래스를 별도로 구분해야한다.
22. 그 클래스는 _declspec(dllimport)로 바꿔준다.
23. using namespace를 쓸때는 기존에 해당 이름을 사용하는 클래스나 함수가 있어야 한다.
24. 그래서 하나 만들어서 있는척 함.
25. 클라이언트의 bin 폴더에 Engine.dll을 넣어준다.
26. Base를 수정하면 다시 레퍼런스 폴더에 lib를 새 버전으로 갱신해주고, 클라이언트의 bin 폴더에 dll를 갱신해줘야한다.
27. 이 과정이 너무 귀찮다.
28. 그래서 배치 파일을 만든다.
Udate_lib.bat 배치파일을 만든다.
29. xcopy /옵션	.복사해야할 파일or폴더	.복사 받을 폴더.
30. 단, 엔진에 있는 코드를 복사하면 export가 그대로 들어온다. 이게 맞나?
31. 매크로로 ENGINE_DLL을 만들어서 엔진에서 쓸땐 export로, 클라이언트에서 쓸땐 import로 바뀌도록 만든다.
32. 어떻게?  매크로 IF로 만든다. 엔진 프로젝트의 전처리기 정의에 들어가면 DLL프로젝트 이름+EXPORTS가 들어가 있다. 클라이언트엔 없는 정의다. 따라서 이걸 이용하면 된다.

2022-05-24 3일차

1. 라이브러리 안에 함수의 구현부를 구현한다. = 정적 링크 라이브러리
2. 하지만 우리가 만드는 라이브러리는 동적 링크 라이브러리다.
3. 실질적으로 코드가 담기는 파일은 lib이다.
4. DLL에서 lib는 링커의 역할로 exe 안에 라이브러리 파일이 담기긴 하지만 실제 코드는 담기지 않고 lib이 DLL로 코드를 찾아간다.
5. exe 파일 크기는 작을수록 좋다.
6. 따라서 찾아가려면 exe파일과 DLL은 같은 폴더 안에 있어야 한다.
7. 정적 링크 라이브러리는 함수 호출 속도가 좀 더 빠르다.
8. 정적 링크 라이브러리의 경우 라이브러리의 코드가 바뀔 경우 exe를 다시 빌드해야한다. 
하지만 동적 링크 라이브러리의 경우 DLL만 바꿔주면 된다.
9. 회사 가면 빌드가 몇시간씩 걸리기도 한다. 그렇다면 정적 링크 라이브러리를 쓴다면? = 자주 빌드한다. = 개손해다.
10. CDevice를 만드는데, g_hWnd와 WINCX WINCY를 쓸 수 없다. 왜? 클라이언트에 있는 디파인이라서.
11. 그래서 Engine_struct.h를 만든다.
12. 거기서 클라이언트에서 사용할 값을 담는다.
13. InitDevice와 SetParam에서 GRAPHICDESC을 매개변수로 준다.
14. 프로젝트 속성 - 링커 - 입력 - 라이브러리(d3d9.lib) 추가
15. 디바이스 사이즈 = 판의 사이즈, 늘리면? 늘어난다.
16. 그래픽 디바이스 코드 봄
17. 101줄 SwapEffect = 디스커드. 기존에 스왑은 폐기한다.
18. 108줄, 109줄 중요하다. 깊이 버퍼에 따라서 막그려도 포지션에 따라서 그려진다. 가려지거나, 그 위에 그리거나.
버퍼 = 저장받기 위한 메모리 덩어리
깊이 버퍼란? 깊이를 저장하기 위한 메모리 공간
DX는 화면 버퍼를 만들때, 똑같은 사이즈의 뎊스 스텐실 버퍼를 만든다.
따라서 109줄의 D3DFMT_D24S8은 뎊스(UNORM)에 24비트, 스텐실(UINT)에 8비트를 할당한다.
UNORM은 0~1사이의 소수점 이하 자리만 저장한다. 따라서 float(32비트)보다 소수점 정밀도는 높다.
뎊스는 카메라로부터의 깊이를 저장한다.
19. 129줄 디바이스 클리어할 때 ZBUFFER를 초기화한다. 단, 매개변수를 보면 깊이 버퍼를 1로 초기화 한다.
20. 준내 멀리 있는 물체를 그릴 필요가 있을까? 복잡한 랜더링 파이프라인을 거치고 1픽셀을 찍을 필요가 없다.
따라서 카메라는 최대 거리와 최소 거리를 정의한다.
깊이 버퍼는 이 값을 노멀라이즈하는 것이다. 최대 거리를 1로, 최소 거리를 0으로 잡는다. 따라서 모든 물체는
1과 0 사이의 소수점 값으로 표현된다.
'0.f ~ 1.f'
네모 오브젝트를 그린다.
해당 픽셀의 깊이를 꺼내온다(초기값 1)
그래서 해당 픽셀이 깊이 테스트를 통과하면 해당 픽셀의 네모 픽셀(깊이 포함)을 기록한다.
모든 오브젝트가 해당 테스트를 거쳐서 픽셀에 오브젝트 픽셀을 기록하고
가장 마지막에 깊이 테스트를 통과한 모든 픽셀을 화면에 그린다.
이 것이 '깊이 테스트'다.

그렇다면 뎊스 버퍼가 Device의 버퍼와 같은 사이즈인 이유는?
대응되는 모든 픽셀에 깊이를 기록해야하기 때문이다.

21. 깊이 테스트의 문제점.
하늘을 어떻게 만들 것인가?
21-1. 큐브 그리기
21-2. 구체로 그리기
21-3. 반구로 그리기

조건1. 하늘이 너무 크면 픽셀이 깨진다.
조건2. 하늘의 위치가 고정되면 플레이어가 탈출할 수 있다.

하늘이 큐브로 카메라를 따라다니게 한다.
하늘의 크기가 작아야한다.
그렇다면 하늘의 깊이가 카메라랑 가깝기 때문에 화면을 덮는다!!
하늘의 깊이를 따로 둘 순 없나?
정답은 깊이 테스트의 조건을 줄 때 하늘만 예외처리하면 된다.
하늘의 깊이를 통과한다.
하늘의 깊이를 기록하지 않는다!!!! 픽셀을 하늘 픽셀로 바꾸더라도, 깊이는 1로 유지한다.

스텐실 버퍼는 8비트 즉 0~255 값을 기록하는 것이다.
스텐실 테스트를 먼저하고
깊이 테스트를 한다.

거울은 앞에 있는 픽셀을 가져다가 찍는 것이다.


2022-05-25 4일차

1. 게임인스턴스에서 모든 싱글톤(MGR)들을 소유하고 오픈할 기능들만 게임인스턴스 클래스에서 함수를 호출하게 만든다.
2. 라이브러리가 커지는 것을 방지하기 위해 쓴다.
3. 게임 인스턴스는 MGR의 레퍼런스 카운트를 늘려야 할까?
4. 늘려야 한다. 싱글톤 객체는 본인 스스로 주소를 기억하기 때문에 원본은 본인에게 있다.
5. 진짜 필요한 함수만 클라이언트 개발자에게 오픈한다.
6. 전방선언 문제: 엔진 네임스페이스 안에 있는 전방선언은 인식이 불가능하다.
7. 해결방법: BEGIN(Engin)와 END(Engin)을 선언하고 그 사이에 전방 선언을 한다.
8. 메모리 릭 체크 디버그 모드에서만 할 수 있도록 한다.
9. 4005번 warning disable 지우기
10. Release_Engine() 엔진 인스턴스 안에 있는 모든 매니저를 지운다.
11. Level = Scene LevelMgr는 엔진에 있어야 한다.
12. 로고... 로딩... 게임 플레이... 등등 레벨
13. 객체들이 디바이스 포인터를 저장한다.
14. 레벨은 클라에게 보여줘야해서 ENGINE_DLL을 붙여준다.
15. 원시 타입을 새로 typedef한다. 왜? 회사에서 코드 관리하려고 쓴다.
시간이 지나면서 바이트가 바뀔 수 있다.
예) 서비스를 20년동안 했다. 이제부턴 업그레이드되서 long이 8바이트로 바뀌었다면?
메모리 사용량이 늘어날 수 있다. 이 경우엔 소스코드의 모든 long을 short으로 교체해야할까?
typedef을 해둔다면 일괄적으로 수정할 수 있다.
16. 구조체 재정의를 typedef할 수 있다. 맛있다...
D3DXVECTOR4를 상속받으면 그 기능과 함께 추가적인 함수를 쓸 수 있다.
단점: _float4 + _float4 하면 안된다. 연산자 오버로딩이 안되서. 결국 내가 다 재정의해야한다...

2022-05-26 5일차

1. 레벨 매니저에서 오픈 레벨 만듬.
2. 레벨을 포인터로 받고 현재 레벨을 Safe_Release 해준다.
3. 레벨 매니저가 Free될때도 현재 레벨을 Safe_Release 해준다.
4. 틱 만듬
5. MainApp에서 로고 레벨을 오픈한다.
6. 레벨을 오픈할 때 무조건 로딩을 호출하고 레벨로 간다.
7. 메인앱에서 디바이스 받아오기(이중 포인터로)
8. MainApp::Open_Level에서 로딩클래스에게 매개변수로 받아온 enum 값 넘겨주기(어떤 Scene을 로딩할 것인지)
9. 로더 클래스 만들 예정이다.
10. 로더 클래스는 다음 레벨에 대한 자원 준비 과정을 거칠 것.
11. 순수하게 자원 로딩을 하기 위해 만드는 클래스.
12. 레벨 로딩은 로더가 자원을 로드하는 동안 화면에 뭔가를 보여준다.
13. 틱 호출 순서를 GameInstance에서 담당한다.
14. Level_Loading의 업데이트에서 끝났는지 확인, 랜더에서 뭘 로딩하고 있는지 텍스트를 받아와서 출력한다.
15. 로더에서 쓰레드 생성한다.
16. 쓰레드로 돌릴 함수는 _stdcall 호출 규약을 붙여줘야 하는데 WinAPI에서는 APIENTRY라는걸로 미리 재정의해놨다.
17. 매개변수로 넘겨주는 void*는 뭘까? 바로 로더 클래스의 인스턴스를 넘겨준다(this)
18. 로더 클래스의 정보를 사용하기 위함이다.
19. 크리티컬 섹션의 정보는 로더가 가지고 있다. 
20. 따라서 매개변수로 받아온 로더 클래스의 인스턴스를 통해 크리티컨 세션 정보를 받아온다.
21. CLoader::Free() 함수 안에 WaitForSingleObject() 쓰레드가 끝날때까지 기다리겠다.
22. 레벨 매니저의 Open_Level() 이전 레벨에서 사용한 자원들을 모두 소거하는 코드를 심는다.
23. 오픈레벨에서 eLevelID를 가져올 수 있나? 없다. 왜? enum은 클라이언트에 있는 정보기 때문이다.
24. 따라서 매개변수로 _uint로 가져온다.

GetShared() //레퍼런스 카운트 올림
GetWeaked() //레퍼런스 카운트 안올림

2022-05-27 6일차
1. 게임오브젝트 클래스 만듬
2. 게임오브젝트 매니저 만듬
3. 레벨 별로 오브젝트 리스트를 만든다. m_Objs[LEVEL_END]
4. LEVEL 종류에 STATIC을 만들어서 유지해야할 객체들은 STATIC에 보관한다. (예: UI, 플레이어)
5. Layer 클래스 만듬. Layer 클래스는 list<CGameObj*>와 같다..
6. 객체의 생성속도를 빠르게 하기 위해서 프로토타입 패턴을 쓰겠다.
7. 이니셜라이즈 프로토타입과 일반 구분하기.
8. 프로토타입 패턴을 왜 쓰냐? 데이터베이스에서 한 번만 데이터를 읽어 오려고 쓴다.
9. Azure PlayFab << 구글 파이어베이스 같은거 

오후 4:18 2022-05-30 7일차
-CObject_Manager.cpp-
1. Tick에서 모든 레이어에 있는 오브젝트를 돌린다.
어차피 레벨이 바뀌면서 기존 레벨의 오브젝트를 전부 지울 예정이라서 전부 돌려도 상관없다.
-CMainApp.cpp-
2. 레벨의 개수 넘겨줘야됨.
-컴포넌트-
3. 다 아는 내용
4. 부모클래스더라도 자식 클래스에서 부모의 함수를 사용할 것이라면, 오픈해야한다.
-Prototype_Mgr-
5. 컴포넌트들이 무겁기 때문에 레벨별로 프로토타입을 관리한다.
6. Reserve_Container(레벨 인덱스), 미리 레벨 개수만큼 공간 할당
-CRenderer-
7. 이거 아니다......... 랜더 매니저다..........걍.............

오후 4:18 2022-05-31 8일차
-CRenderer.cpp-
1. Draw_RenderGroup: 리스트를 순회하면서 그린다.
그리고, 리스트를 비운다. 단, 참조가 지워지는 것이기 때문에 Release를 해준다.
2. Add_RenderGroup: 그룹 enum과 게임 오브젝트를 넘겨준다.
3. 알파 블렌딩이란? 색을 섞는 것. 투명도에 따라서 색을 섞어서 그리는 것이다.
알파 값을 이용해서 색을 섞는다.
4. 알파 테스트를 이용하면 알파 블렌딩을 편하게 할 수 있다.
5. 알파 테스트를 통과하면 그린다.
6. 알파 테스트 -> 깊이 테스트 순서다.
7. 즉, 알파 테스트의 조건을 통과하지 못한다면 깊이 테스트를 통과하지 못한다.
8. 단점: 알파 테스트는 섞는다는 개념이 없다.
9. 논 알파 블렌드에서 그리고 있는 지형과 같은거랑 같이 그려도 된다. 
즉, 알파 테스트를 할 오브젝트들은 논 알파 블렌드에서 그린다.
하지만 알파 블렌드를 사용할 버퍼는 알파 블렌드에 들어간다.
10. 블렌딩이 필요한 얘들은 멀리 있는 버퍼부터 그려야 한다.
원래는 깊이 테스트를 해서 그리는 순서는 상관이 없었으나, 알파 블렌딩에서는 색을 섞어야하므로 멀리 있는 버퍼부터 그려야 한다.
즉, 알파 소팅 개념이 생기는 것이다.(깊이가 깊은 버퍼 순서대로 정렬한다.)
결론: 멀리 있는 버퍼를 먼저 그려야 알파 블렌딩이 자연스럽게 진행된다.
11. UI는 Z Enable을 꺼버린다. 깊이 테스트를 하지 않고 그리겠다. 즉, 무조건 덮고 그리겠다는 뜻이다.
12. 렌더 그룹에 RENDER_DEBUG를 붙여서 디버그 콜라이더라던지를 그릴수도 있다.
13. 하늘에서 눈이 내린다. 이 것은 알파 테스트인가 블렌드인가?
정답: 알파 테스트다. 눈 객체가 2000개, 3000개 있다면 그걸 전부 알파 소팅해야한다. 따라서 테스트로 그리는게 맞다.
14. 폭발해서 연기 이미지가 나온다. 이 것은 알파 테스트인가 블렌드인가?
정답: 알파 블렌딩. 입자가 2000개일리가 없으니 끽해야 20개다. 따라서 알파 소팅하기 적합하다.
15. 나무의 나뭇잎은 알파 테스트인가 블렌드인가?
정답: 나뭇잎은 어디서 보더라도 볼륨감 있게 그리기 위해 X모양으로 서로 네모를 교차해서 그린다.
X모양으로 서로 교차한다면 여긴 알파 소팅을 할 수 있나? 불가능하다. 알파 테스트로 그린다. 
16. 알파 테스트란 일정 알파값 이하라면 해당 부분을 그리지 않겠다는 것이다. 
예를 들어 텍스쳐 파일은 사각형이고 사용하지 않는 부분은 알파 테스트로 제거하는 과정을 거친다.
-MainApp.cpp-
17. Ready_Component 어쩌구저쩌구 추가
-Component_Mgr.h-
18. 모든 컴포넌트 헤더는 Engine의 컴포넌트 매니저 헤더에 선언한다.
엔진헤더랑 뭐가 다른가?
-CBackground.cpp-
19. SetUp_Component() 안에서 (CRenderer*) 원시 형변환을 사용함. dynamic_cast로 바꾸기.
20. 클라이언트 개발자의 개발 편의성을 높여준다.
즉, 레퍼런스 카운트 증가 여부를 클라 개발자가 하기보단 엔진에서 해결하자.
21. 내가 그려지는 경우에만 Add_renderGroup한다.

오후 4:13 2022-06-02 9일차
-CVIBuffer.cpp-
1. 점을 찍어서 네모를 그릴 것이다.
2. m_pVB는 정점 정보를 담고 있는 COM 객체다.
3. DX9에서 최대 정점 변수는 64개까지 밖에 없다. 즉, FVF 종류가 64개다.
4. 그래서 그때그때 만들어서 사용해라.
5. Create_VertexBuffer() 말 그대로 정점 버퍼를 생성해준다.
6. u, v 좌표 씀. u, v란 뭘까? 비율이다. 상대적인 좌표. 
이미지의 가로와 세로 사이즈는 무조건 1이다.
가로 기준 비율이다. 가로는 무조건 1이다.
7. 한 번 할당한 정점의 정보는 바꾸지 말아야 한다.
8. m_iStride는 정점 하나의 바이트 크기를 이야기한다. 표준적인 이름이다.
9. m_iNumVertices는 정점의 개수를 이야기한다.
10. Usage가 0이면 정적 메모리 공간에 두겠다는 뜻.
11. D3DUSAGE_DYNAMIC은 바꿀 수 있다. 
12. 하지만 선생님은 정적 버퍼로 만든다. 왜? 랜더링 속도가 빠르기 때문이다.
13. 정점 위치가 실제 랜더링 위치가 아닌 이유는? 버텍스 프로세싱 때문이다. (중요)
14. FVF는 DX가 지원하는 내에 커스터마이징해서 쓸 수 있다.
15. D3DFVF_TEX1은 해당 정점이 텍스쳐 좌표를 한개 가지고 있다는 뜻이다! 최대 8개의 텍스쳐 좌표를 쓸 수 있다.
16. D3DFVF_TEXCOORDSIZE2(0)는 float 2개짜리 위치 벡터를 쓰겠다는 뜻이다. (안쓰면 디폴트)
17. 몇 번째 위치에 위치 벡터인지, 텍스쳐 좌표인지 DX가 순서는 모른다.
18. 따라서 꼭 정해진 순서에 맞춰서 써야한다. 즉, FVF에 선언되어 있는 순서대로 집어넣어야 한다.
19. 자식 클래스에게 FVF를 주자.
20. D3DPOOL은 할당할 위치를 정하는 것이다. 
default는 GPU에 저장한다. default는 랜더링 속도가 졸라 빨라진다.
단, RAM의 경우 가상 메모리 공간이 정해져 있고, 그 공간 안에서 자유롭게 쓴다. 
하지만 GPU는 공간이 정해져 있고 나중에 쓰고 싶지 않아도 써야되는 케이스때문에 default는 쓰지 마라.
System_Mem 쓰지마라. 메인보드 메모리에 저장하는데 느리다.
Managed는 자동으로 효율적인 공간을 찾아간다. 이거 써라.
-CVIBuffer_Rect.cpp-
21. Initialize_Prototype()에서 Lock()은 이 정점 정보를 수정하기 위해서 잠근다. 라는 뜻이다. 평상 시엔 열려 있다.
내가 여기서 수정할동안에는 손대지 말라는 뜻이다.
22. Lock(가장 앞 바이트, 얼만큼 가져올지, 포인터의 주소); 포인터의 주소를 가져오는 이유가 뭐다? 주소 자체를 바꿔주기 위해서다.
23. void**는 오직 void*만 담을 수 있다. void**는 void*같이 자유로운 형변환을 지원하지 않는다.
24. 벡터와 행렬 곱은 벡터를 행렬의 상태로 변환하기 위한 작업이다.
25. 정점의 위치 벡터와 플레이어의 월드 행렬을 곱하면? 적용되는 것이다!
26. 월드 행렬을 다르게 만든다.  상태 행렬은 월드 행렬의 직교 행렬이다.
27. 상태 행렬에서 _14, _24, _34는 0이다. 왜냐? 방향 벡터기 때문이다.
월드 변환 행렬은 다음과 같이 이루어진다.
1행 Right 벡터
2행 Up 벡터
3행 Look 벡터
4행은 월드공간의 포지션 벡터다.

만약 오른쪽으로 90도 회전했다면?
1행은 0  0 -1  0 (Right 벡터: Z축 기준 -방향을 가르킨다.)
2행은 0  1  0  0 (Up 벡터: Up은 그대로다.)
3행은 1  0  0  0 (Look 벡터: X축을 바라보고 있다.)
4행은 0  0  0  1 (포지션은 바뀌지 않았다.)

플레이어를 바라보는 몬스터의 행렬은?
과정1. Look 벡터 세팅: 플레이어 - 몬스터한 좌표를 노멀라이즈해서 3행에 때려박는다.
과정2. Up 벡터 세팅: 그대로니까 그대로 넣어준다.
과정3. Right 벡터 세팅: 직교한 벡터를 넣어주면 된다! Look과 Up을 외적한 행렬을 Right에 세팅해주면 됨
과정4. 위치 행렬 세팅: 위치를 때려 박는다.

오후 4:16 2022-06-03 10일차
1. 카메라 개념 추가
2. 3차원 공간에서 2차원으로 어떻게 변환할까? Z축을 날려버리면 된다.
그 과정이 2차원 좌표계로 바꾸는 작업이다.
3. 2차원 좌표계를 한 번 거친 뒤, 화면 공간으로 옮긴다.
4. 로컬 스페이스 -> 월드 스페이스 -> 뷰 스페이스(2차원 좌표계)
뷰 스페이스 변환 원리: 카메라가 시야에 들어온 랜더링 물체들을 전부 가지고 0 좌표로 이동한다.
마치 카메라가 로컬에 있는 것과 같이 보인다. (Look이 z의 양의 방향, Right가 X축, Up이 Y축)
5. 카메라의 월드 행렬의 역행렬을 구하면? 
카메라 월드 행렬 * 역행렬 = 0좌표(로컬로 변환)
6. D3DXMatrixLookAtLH(반환 행렬, 카메라의 위치, 바라보는 방향, D3DXVECTOR3(0, 1, 0));
카메라엔 스케일 값이 없다.
7. 벡터의 외적은 외적 순서에 따라서 왼쪽이 나올지 오른쪽이 나올지 바뀐다.
A외적B와 B외적A는 방향성이 다르다.
A외적B의 결과 벡터는 A기준 오른쪽 방향이다.
B외적A의 결과 벡터는 B기준 오른쪽 방향이다.
8. 하지만 현재까지 카메라가 가져온 도형의 크기가 똑같다. 원근감이 없다. 원근감을 주려면?
Z로 나누고 Z로 소거
9. X를 Z로 나누면? 3, 0, 3과 2, 0, 2는 Z로 나누면 모두 1, 0, 1이므로 카메라 안에 있게 된다.
10. 줌인 효과는 어떻게 주는가? FOV를 줄인다. 카메라 영역을 줄이고, 그걸 잡아 당겨서 모니터에 맞추면? 줌인되는 효과가 나타난다.
11. 따라서 투영은 무조건 Z나누기.
12. 무조건 시야각이 90도가 나온다.
13. 그럼 시야각을 바꾸고 싶다면 어떻게 해야 하는가?
14. 모든 투영 알고리즘은 90도가 고정이다. 만약 60도 시야각을 만들었다면, 걔네를 잡고 90도로 늘린다!!
15. 깊이 버퍼는 정수부를 사용하지 않고 소수점만 사용한다. 즉 0~1사이의 값에대한 테스트만 할 수 있다.
16. Z나누기를 전부 다 했을때, 카메라 입장에서 깊이의 최소 거리와 최대 거리를 잡아야 한다.
17. 그 개념이 니어와 파다.
18. ((F * Z) / (F - N)) - ((F * N) / (F - N))
19. Z가 F일때 F가 나온다. Z는 1이 나와야하는데, F가 나온다?
결과적으로 F로 다시 나누면 1이 나온다.
20. 투영 행렬
{1 / tan(fov/2) / Aspect, 0, 0, 0}
{0, 1 / tan(fov/2), 0, 0}
{0, 0, f/f*n, 1}
{0, 0, -f*n / f-n, 0}
21. 투영 좌표계의 결과물들을 뷰포트로 옮기려면? 만약 정사각형 좌표계에서 직사각형 화면으로 옮긴다면
도형들이 가로로 길게 늘어질 것이다. 해당 현상을 방지하기 위해 Aspect 개념이 나온다.
Aspect는 가로세로 비율이다.  투영행렬의 _11에 Aspect로 미리 나눈다.
즉, 넓어질 것만큼 미리 줄여놓고 늘리면? 원본의 크기가 나오게 된다.
22. 투영행렬은 실제 투영을 하는 행렬은 아니다. 원활한 투영 변환을 위해 미리 사전작업하는 행렬이라고 생각하면 된다.
아직 뷰 스페이스의 과정에 있다.
여기서 W(Z값)으로 나누면 투영 스페이스로 들어간다.
23. D3DVec3TransformCoord 함수는 위치 벡터와 행렬을 곱하고, 해당 결과의 w값으로 결과를 다시 나눈다.
즉, W(Z값)으로 나누는 과정을 하지 않아도 TransformCoord 함수를 사용하게 되면 투영 스페이스로 이동하게 된다.
주의사항!!!!!!!!! :: 쉐이더에서 mul 함수 안에선 Z나누기를 안한다!!!!!! Coord와 차이점을 기억해야한다.
24. 투영행렬까지 곱하면 0~F 사이의 값이 나온다.
25. D3DXMatirxPerspectiveFovLH가 투영 행렬 계산 함수다.
D3DXMatirxPerspectiveFovLH(카메라 각도, WINCX / WINCY, 니어, 파) 정확하지 않음
26. 차원 변환은 W 나누기다. 투영 변환 행렬은 차원 변환이 아니다. 사전 작업일 뿐이다.

오후 4:16 6/7/2022 11일차
1. 레스터라이즈: 정점에게 둘러 쌓여진 픽셀의 정보를 채우는 것이다.
2. 정점은 배열 형태로 저장된다. 같은 타입의 데이터를 연속적으로 할당.
3. 앞면 컬링은 DX가 기본적으로 한다.
4. 점을 그리는 순서로 앞면을 알려줘야한다. DX9은 기본적으로 CW 방향으로 순서를 정한다.
CW 방향이란? 시계 방향.
그렇다면 뒷면의 버텍스는 어떤 방향으로 지정해줘야 하는가?
CCW 방향으로 설정한다. 반시계 방향으로.
-Vertex_Rect.cpp-
5. 버텍스 정점 좌표 채워줌
6. 점 하나로 네모를 그릴 수도 있다. 단, 네모의 회전은 어떻게 되어야 하는가?
그래서 점 하나로 네모를 그리면 무조건 카메라를 바라보게 만들어진다.
7. LINESTRIP: 라인을 이어서 그린다. 마지막 정점 기준으로 이어서 그린다.
8. TRIANGLELIST: 삼각형 정보
9. TRIANGLEFAN: 안씀. 처음에 삼각형을 그리고 점을 하나 찍으면 마지막으로 그려진 선분과 점을 이어서 삼각형을 만든다.
10. 버텍스 버퍼를 장치에 바인드하는건 당연한 일이다.
서로 달느 버텍스 버퍼를 묶어서 바인드할 수도 있다.
(예상: 같은 파이프라인을 통과하는(같은 쉐이더를 적용하는) 버텍스들을 묶어서 바인드하면 최적화가 되지 않을까?)
11. Vertex_Buffer 관련 코드들 계속 추가함.
12. (숙제) MainApp에서 Rect를 프로토타입으로 만들기.
13. (숙제) Rect.cpp에서 Clone 채우기.
14. 인덱스 버퍼 자료형의 사이즈는? 2바이트라면 6.5만까지 가능하고, 4바이트라면 억단위까지 가능하다.

오후 4:22 6/8/2022 12일차
-VIBuffer.h-
1. _uint m_iIndicesSizePerPrimitive = 0; 도형 하나를 그리기 위해 사용되는 인덱스들의 크기
2. (숙제)CreateIndexBuffer 채우기, Rect와 부모 둘다 있음
-VIBuffer_Rect.cpp-
3. (숙제)Initalize_Prototype 채우기
-VIBuffer.cpp-
4. DrawIndexedPrimitive(타입, 더해줄 인덱스(해당 값만큼 모든 인덱스에 더함),....)
5. 텍스쳐 로드(이전 유쌤 코드) 추가할 것임.
6. Texture 필터 추가
7. (숙제)CTexture 클래스 채우기
-CTexture.cpp-
8. 스카이박스는 큐브인데, 총 6개의 면이 존재한다.
9. 텍스쳐를 읽어오는 방식에 따라 DX 자료형이 달라진다.
LPDIRECT3DCUBETEXTURE9: 가로로 긴 텍스쳐를 6개로 나눠서 로드한다.
LPDIRECT3DTEXTURE9: 가로로 긴 텍스쳐를 로드하더라도 한 장으로 취급한다.
LPDIRECT3DBASETEXTURE9: 위 두 클래스의 부모다. 따라서 해당 타입으로 묶어서 저장할 수 있다.
10. 매개변수로 받아온 경로는 %d가 포함되어있다.
11. 만약 한 장짜리면 이미지에 번호가 없는데 어떡하냐?
어차피 wsprintf에서 %d가 없다면 i가 무시된다.
12. 사용할 텍스쳐가 같다면 새로 바인드할 필요가 없다.
13. 마찬가지로 Render에서 Set해준 정보는 다시 해줄 필요없다.
-Loader.cpp-
14. (숙제)텍스쳐 로드
15. 주의: 밖으로 내보내는 클래스는 템플릿 타입 사용을 자제하세요.
-Background.h-
16. 텍스쳐 컴포넌트 추가
-MainApp.cpp-
17. (숙제)SetUp_RenderState() 함수 채우기
18. UV 좌표를 2배씩 했더니 이미지가 4장 그려진다.
이유는? 2인 경우 1짜리 두개니, 가로로 2장 세로로 2장 그린다.
19. 지형을 그릴때 사용한다. 지형 크기가 크다고 가정할 때, 한 장의 이미지를 맞춰서 키운다면
픽셀이 보이게 된다. 따라서 이어붙여서 해결한다.

오후 4:16 6/9/2022 13일차
-Background.h-
1. Get_Component 같은 함수 만듦.
2. Add_Component 같은 함수 만듦.
3. 월드 행렬의 위치 벡터에 월드 행렬의 방향 벡터를 더한다? 스케일의 영향을 받게 된다.
4. 따라서 항상 사용하기 전에 정규화한다.
5. 회전 행렬은 어차피 4행이 0,0,0,1이므로 Coord나 Nom이나 같다. 하지만 명시적으로 Nom을 쓰자.

숙제:
-GameObject.h-
1. Get_Component 만들기
2. Add_Component 만들기
-Transform.h-
3. Transform 채워오기 (과제)
-Background.h-
4. Background에 Transform 붙여주기
5. 카메라 세팅
6. 몬스터가 플레이어 처다보면서 따라오게 만들어라 (과제)
7. 쳐다보는 기능: Look을 구함. Up(0,1,0)과 Look을 외적 Right를 구함. Look과 Right를 외적 진짜 Up을 구함
그걸 Transform에 세팅. 끝

오후 4:14 6/10/2022 14일차
1. 복습.
2. 타이머 만들자 끝

오후 4:31 6/13/2022 15일차
1. 카메라의 역행렬
2. 카메라 만들기
3. 지형깔기

숙제:
1. 마우스 이전 프레임과 현재 프레임 비교해서 이동량만큼 카메라 회전시키기 (과제)
2. 바닥깔기 (과제)

오후 5:29 6/14/2022 16일차
1. 샘플링: 특정 영역을 가져온다. 텍스쳐에서 UV좌표를 이용해 특정 지점을 가져오는 것도 샘플링이라고 한다.
2. 샘플러: 저장소 즉, 텍스쳐다.
3. DX 경로에 텍스쳐 툴이 있다. 여기서 밉맵을 생성할 수 있다.
4. DX9은 이미지를 2의 n 사이즈로 로드한다. (100x100으로 넣더라도 64x64로 변경된다.)
5. DX9은 이미지를 로드할 때 여러 사이즈의 텍스쳐를 로드한다. 이 것이 밉맵이다.
6. 화면에 맞춰서 이미지가 더 커지거나 더 작게 그려져야 한다. 
이 경우엔 픽셀 사이를 생성하거나 탈락시킨다. 따라서 DX9은 텍스쳐를 사이즈별로 미리 만들어둔다.
DX11은 안해준다..........





